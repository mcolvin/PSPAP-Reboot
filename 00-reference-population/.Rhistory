install.packages(pander)
install.packages(pander)
library(pander)
getwd()
bends<- read.csv("./dat/bend-data.csv")
head(bends)
names(bends)<- tolower(names(bends))
bends<- subset(bends,b_segment %in% c(1,2,3,4,7,8,9,10,13,14))
dim(bends)
head(bends)
str(bends)
library(reshape2)
library(plyr)
library(knitr)
library(pander)
?order
segs=c(1,2,3,4,7,8,9,11,10,13,14),
bends=NULL,
fish_density=1,
nyears=10,
phi=0.95)
(segs=c(1,2,3,4,7,8,9,11,10,13,14)
)
bends=NULL
fish_density=1
nyears=10
phi=0.95
dim(phi)
tmp<- subset(bends, b_segment%in% segs)
tmp<- subset(bends, b_segment %in% segs)
head(bends)
# READ IN BEND DATA FOR RPMA 2 (UPPER) AND 4 (LOWER)
bends<- read.csv("./dat/bend-data.csv")
# make data.frame column names lower case
names(bends)<- tolower(names(bends))
bends<- subset(bends,b_segment %in% c(1,2,3,4,7,8,9,10,13,14))
tmp<- subset(bends, b_segment %in% segs)
tmp
tmp<- tmp[order(tmp$b_segment, tmp$bend_num),]
tmp
?aggregate
aggregate(bend_num~b_segment,tmp,length)
str(tmp)
bends_in_segs<-aggregate(bend_num~b_segment,tmp,length)
?rep
rep(1:nrow(bends_in_segs),bends_in_segs$bend_num)
phi_indx<-rep(1:nrow(bends_in_segs),bends_in_segs$bend_num)
head(tmp)
phi_indx==tmp$b_segment
length(tmp$b_segment)
tmp$b_segment[155:158]
phi_indx[155:158]
out<- matrix(0,nrow(tmp), nyears)
out
?rpois
out[,1]<- rpois(nrow(out),
lambda=fish_density*tmp$length.rkm)
out
?rbinom
phi
phi[1,2]
for(i in 2:nyears)
{
# SET UP VECTOR OF SEGMENT
# SPECIFIC SURVIVALS
phi_t<- phi
out[,i]<- rbinom(nrow(out),
size=out[,i-1],
prob=phi_t)
}
out
reference_population<- function(segs=c(1,2,3,4,7,8,9,11,10,13,14),
bends=NULL,
fish_density=1,
nyears=10,
phi=0.95)
{
# this function allocates fish to bends within a segment
# probabilistically given bend weights
# inputs
## segment: segment [1,2,3,4,7,8,9,10,13,14]
##     fish_density: density of fish within segment; fish/rkm
## type: input for fish type [hatchery, natural]
# outputs
## out: a matrix where each row is a bend and
##   each column represents a year; number
# assumptions
## no movement
## no recruitment
## survival homogenous for individuals
## ERROR HANDLING
if(dim(phi)[1]!=length(segs) &
dim(phi)[1]!=nyears) #should this be dim(phi)[2]!=nyears?
{return(print("Survival(phi) needs to be a matrix \n
with rows equal to the number of segments \n
and the same number of columns as years-1 to simulate"))}
# GET BEND INFORMATION
tmp<- subset(bends, b_segment %in% segs)
tmp<- tmp[order(tmp$b_segment, tmp$bend_num),]
bends_in_segs<-aggregate(bend_num~b_segment,tmp,length)
phi_indx<-rep(1:nrow(bends_in_segs),bends_in_segs$bend_num)
# MATRIX OF ABUNDANCES TO RETURN
out<- matrix(0,nrow(tmp), nyears)
# INITIAL ABUNDANCES
## PULL NUMBER FROM A POISSON AFTER ADJUSTING
## DENSITY FOR BEND SIZE
out[,1]<- rpois(nrow(out),
lambda=fish_density*tmp$length.rkm)
# SIMULATE DYNAMICS
## SURVIVAL
for(i in 2:nyears)
{
# SET UP VECTOR OF SEGMENT
# SPECIFIC SURVIVALS
phi_t<- phi[phi_indx,i-1]
out[,i]<- rbinom(nrow(out),
size=out[,i-1],
prob=phi_t)
}
return(out)# return relevant stuff
}
segs<- c(1,2,3,4,7,8,9,11,10,13,14)
nyears<- 20
beta0<- 2.9444
phi<-matrix(plogis(beta0),length(segs),nyears-1)
fish_density<- 10
reference_population(segs=segs,
bends=bends,# BENDS DATAFRAME
fish_density=10, # FISH DENSITY PER RKM
phi=phi) # MATRIX OF YEAR TO YEAR AND SEGEMENT SPECIFIC SURVIVALS
reference_population(segs=segs,
bends=bends,# BENDS DATAFRAME
fish_density=10, # FISH DENSITY PER RKM
nyears=nyears, #NUMBER OF YEARS TO PROJECT
phi=phi)
reference_population(segs=segs,
bends=bends,# BENDS DATAFRAME
fish_density=10, # FISH DENSITY PER RKM
#nyears=nyears, #NUMBER OF YEARS TO PROJECT
phi=phi)
sim_pop<-reference_population(segs=segs,
bends=bends,# BENDS DATAFRAME
fish_density=10, # FISH DENSITY PER RKM
#nyears=nyears, #NUMBER OF YEARS TO PROJECT
phi=phi) # MATRIX OF YEAR TO YEAR AND SEGEMENT SPECIFIC SURVIVALS
head(sim_pop)
rm(bends, bends_in_segs,out, phi, sim_pop, tmp, bet0, fish_density, i, nyears, phi_indx, phi_t, segs, reference_population
)
rm(beta0)
library(RODBC)
library(digest)
library(plyr)
library(reshape2)
library(MASS)
com3<- odbcConnectAccess2007("C:/Users/sreynolds/Google Drive/Pallid-Sturgeon/analysis-effort/pallids.accdb")
dat<-sqlFetch(com3, "Gear-Specific-Effort")
## CONVERT TO CHARACTER
dat$STARTTIME<- as.character(dat$STARTTIME)
dat$STOPTIME<- as.character(dat$STOPTIME)
## FILL NON TIME FORMATS WITH NA
dat[-(grep(":",dat$STARTTIME)),]$STARTTIME<- NA
dat[-(grep(":",dat$STOPTIME)),]$STOPTIME<- NA
## DROP NAs
dat<- subset(dat, !(is.na(STARTTIME)));dim(dat)
dat<- subset(dat, !(is.na(STOPTIME)));dim(dat)
dat<- subset(dat, !(is.na(SETDATE)))   ;dim(dat)
## MAKE SURE ALL IS UPPER CASE
dat$STARTTIME<- toupper(dat$STARTTIME)
dat$STOPTIME<-toupper(dat$STOPTIME)
## LOAD GEAR DATA
gear_dat<-sqlFetch(com3, "Gear-Meta-Data")
names(gear_dat)[2]<-"gear_type"
## SUBSET OUT DUPLICATE GEARS
# POT02, HN, SHN,TN11, MOT02, OT04, OT02
gear_dat<- gear_dat[-which(duplicated(gear_dat$gear_code)==TRUE),]
## MERGE GEAR TYPE WITH EFFORT DATA
dat<- merge(dat,gear_dat[,c(2,3,4,5,7,10)],by.x="GEAR",
by.y="gear_code",all.x=TRUE)
### UPDATE STOP DATE FOR OVERNIGHTS
dat$STOPDATE<- dat$SETDATE+60*60*24*dat$overnight
## CONVERT ALL TO HOUR FRACTION TIME
## START TIME
dat$start_time<-unlist(lapply(1:nrow(dat),function(x)
{
pp<- NA
xx<-unlist(
strsplit(
dat[x,]$STARTTIME,":"
))
if(length(grep("PM",xx))==0|{length(grep("PM",xx))>0 & xx[1]==12}) # HANDLE AM, NON PM, AND 12PM FORMATS
{
pp<-paste(as.character(dat[x,]$SETDATE)," ",as.numeric(xx[1]),":",
as.numeric(xx[2]),":00",sep="")
pp<-strptime(pp, "%Y-%m-%d %H:%M:%S")
}
if(length(grep("PM",xx))>0 & xx[1]!=12) # HANDLE REMAINING PM FORMATS
{
pp<-paste(as.character(dat[x,]$SETDATE)," ",as.numeric(xx[1])+12,":",
as.numeric(xx[2]),":00",sep="")
pp<-strptime(pp, "%Y-%m-%d %H:%M:%S")
}
return(as.character(pp))
}))
## STOP TIME
# xx<-strsplit(dat$STOPTIME,":")
# hr<- unlist(lapply(xx, `[[`, 1))
# mins<- unlist(lapply(xx, `[[`, 2))
# apply(cbind(hr,mins),1,paste,collapse=":")
dat$stop_time<-unlist(lapply(1:nrow(dat),function(x)
{
pp<- NA
xx<-unlist(
strsplit(
dat[x,]$STOPTIME,":"
))
if(length(grep("PM",xx))==0|{length(grep("PM",xx))>0 & xx[1]==12}) # HANDLE AM, NON PM FORMATS, AND 12PM
{
pp<-paste(as.character(dat[x,]$STOPDATE)," ",as.numeric(xx[1]),":",
as.numeric(xx[2]),":00",sep="")
pp<-strptime(pp, "%Y-%m-%d %H:%M:%S")
}
if(length(grep("PM",xx))>0 & xx[1]!=12) # HANDLE REMAINING PM FORMATS
{
pp<-paste(as.character(dat[x,]$STOPDATE)," ",as.numeric(xx[1])+12,":",
as.numeric(xx[2]),":00",sep="")
pp<-strptime(pp, "%Y-%m-%d %H:%M:%S")
}
return(as.character(pp))
}))
dat$stop_time<- strptime(dat$stop_time,"%Y-%m-%d %H:%M:%S")
dat$start_time<- strptime(dat$start_time,"%Y-%m-%d %H:%M:%S")
## CALCULATE EFFORT
dat$effort<-as.numeric(dat$stop_time-dat$start_time)/60 # EFFORT IN MINUTES
dat<-subset(dat,effort>0)
names(dat)<-tolower(names(dat))
##FIX TYPO IN COLUMN NAME
colnames(dat)[14]<-"standard_gear"
# FIND STANDARD LOWER & UPPER BASIN GEARS
datLB<-subset(dat, standard_gear=="yes" & basin=="LB")
dim(datLB)
LBgears<-unlist(lapply(unlist(levels(datLB$gear)), function(x)
{
lg<-subset(datLB, gear==x)
if(nrow(lg)!=0) return(x)
}
))
datUB<-subset(dat, standard_gear=="yes" & basin=="UB")
dim(datUB)
UBgears<-unlist(lapply(unlist(levels(datUB$gear)), function(x)
{
lg<-subset(datUB, gear==x)
if(nrow(lg)!=0) return(x)
}
))
dfitfunLB<-function(x)
{
datLBgear<-subset(datLB, gear==LBgears[x])
dfit<-fitdistr(datLBgear$effort, "gamma")
#Define Shape and Rate Based on Distribution Fitting
s<-as.numeric(unlist(dfit)[1])
r<-as.numeric(unlist(dfit)[2])
return(c(s,r))
}
dfitfunUB<-function(x)
{
datUBgear<-subset(datUB, gear==UBgears[x])
dfit<-fitdistr(datUBgear$effort, "gamma")
#Define Shape and Rate Based on Distribution Fitting
s<-as.numeric(unlist(dfit)[1])
r<-as.numeric(unlist(dfit)[2])
return(c(s,r))
}
# MAKE A LIST OF DISTRIBUTION PARAMETERS
valuesLB<-unlist(lapply(c(1:12,15,16,18), dfitfunLB))
shapesLB<-c(valuesLB[(2*c(1:length(LBgears))-1)])
ratesLB<-c(valuesLB[(2*c(1:length(LBgears)))])
valuesUB<-unlist(lapply(1:length(UBgears), dfitfunUB))
shapesUB<-c(valuesUB[(2*c(1:length(UBgears))-1)])
ratesUB<-c(valuesUB[(2*c(1:length(UBgears)))])
shapes<-c(shapesLB[1:12],NA,NA,shapesLB[13:14],NA,shapesLB[15],shapesUB)
rates<-c(ratesLB[1:12],NA,NA,ratesLB[13:14],NA,ratesLB[15],ratesUB)
datS<-subset(dat,standard_gear=="yes") #ONLY STANDARD GEARS
datS$tmp<-1 #TO SUM FOR COUNTS
eft<-dcast(datS, basin+gear+gear_id~"observations", value.var="tmp", sum)
eft$mean_effort<-c(round(aggregate(datLB$effort,by=list(datLB$gear),mean)[,2]),round(aggregate(datUB$effort,by=list(datUB$gear),mean)[,2]))
eft$sd_effort<-c(round(aggregate(datLB$effort,by=list(datLB$gear),sd)[,2]),round(aggregate(datUB$effort,by=list(datUB$gear),sd)[,2]))
eft$min_effort<-c(aggregate(datLB$effort,by=list(datLB$gear),min)[,2],aggregate(datUB$effort,by=list(datUB$gear),min)[,2])
eft$max_effort<-c(aggregate(datLB$effort,by=list(datLB$gear),max)[,2],aggregate(datUB$effort,by=list(datUB$gear),max)[,2])
eft$median_effort<-c(round(aggregate(datLB$effort,by=list(datLB$gear),median)[,2]),round(aggregate(datUB$effort,by=list(datUB$gear),median)[,2]))
eft$gamma_shape<-shapes
eft$gamma_rate<-rates
eft<-subset(eft,observations>=10)
eft
getwd()
write.csv(eft, file="C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/effort-analysis/output/effort_dat")
write.csv(eft, file="C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/effort-analysis/output/effort_dat.csv")
write.csv(eft, file="effort_dat.csv")
getws()
getwd()
setwd("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/effort-analysis/output")
write.csv(eft, file="C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
read.csv("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat")
?read.csv
read.csv("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
eft_trial1<-read.csv("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
str(eft_trial1)
write.table(eft, file="C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
read.table("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
eft_trial2<-read.table("C:/Users/sreynolds/Documents/GitHub/PSPAP-Reboot/01-PSPAP-Background/analysis-effort/output/effort_dat.csv")
str(eft_trial1)
str(eft_trial2)
?write.table
