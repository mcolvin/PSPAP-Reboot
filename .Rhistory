return(bg)
})
}
if(!is.null(gear_combi)){return(print("Different gear combinations not supported
at this time."))}
gear_combi<-NULL
if(is.null(gear_combi))
{
ch<-lapply(c("UB", "LB"), function(b)
{
dat<-catch[which(catch$basin==b),]
gears<-unique(dat$gear)
gears<-setdiff(gears, c("MF","OT16"))
bg<-lapply(gears,function(g)
{
pp<- dcast(dat,
fish_id~year+occasion,
value.var="st_code", subset=.(gear==g))
pp$gear<-g
return(pp)
})
bg<-do.call(rbind,bg)
for(i in 2:(ncol(bg)-1))
{
bg[which(is.na(bg[,i])),i]<-0
}
tmp<-matrix(0, nrow=nrow(bg), ncol=max_occ*inputs$nyears)
for(i in 1:ncol(tmp))
{
tmp[,i]<-bg[,i+1]
}
bg$ch<-apply(tmp,1,paste0,collapse="")
bg$freq<-1
bg<-bg[,c("ch", "freq","gear")]
return(bg)
})
}
if(!is.null(gear_combi)){return(print("Different gear combinations not supported
at this time."))}
library(RMark)# NEED TO COMMUNICATION TO PROGRAM MARK
out<-lapply(1:length(ch), function(b)  # LOOP OVER BASINS
{
dat<-ch[[b]]
gears<-unique(dat$gear)
if(length(ch)==1){states<-unique(catch$st_code)}
if(length(ch)==2)
{
if(b==1){states<-unique(catch[which(catch$basin=="UB"),]$st_code)}
if(b==2){states<-unique(catch[which(catch$basin=="LB"),]$st_code)}
}
if(length(ch)!=1 & length(ch)!=2){return(print("Issue with capture history length."))}
outg<-lapply(gears, function(g) #LOOP OVER GEARS
{
datg<-dat[which(dat$gear==g),1:2]
crdms<-process.data(data=datg, # CAPTURE HISTORIES FOR EACH FISH
model="CRDMS",  # MODEL TYPE
time.interval=occs, # FUNKY INPUTS TO DEFINE PRIMARY AND SECONDARY OCCASIONS
strata.labels=c(as.character(states), "U")) #DEFINE STATES
# MAKE ADJUSTMENTS
## Change Psi parameters that are obtained by subtraction so that probability
##  of moving to the unobservable state is determined by subtraction
crdms.ddl<-make.design.data(data=crdms,
parameters=list(Psi=list(
subtract.stratum=rep("U",length(states)+1))))
## Create grouping index for unobserved p and c (i.e., always zero)
up<-as.numeric(row.names(crdms.ddl$p[crdms.ddl$p$stratum=="U",]))
uc<-as.numeric(row.names(crdms.ddl$c[crdms.ddl$c$stratum=="U",]))
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX ASSUMING CONSTANT SURVIVAL
S=list(formula=~1)# SURVIVAL
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX FOR CAPTURE PROBABILITY
# RD CAN DO CAPTURE (P) AND RECAPTURE (C) PROBABILITY
# WE ALLOW P TO CHANGE WITH OCCASION AND STRATA BUT ASSUME C=P AT A GIVEN TIME
# AND PLACE.  THUS, WE FIX C = P USING THE SHARE STATEMENT:  SHARE = TRUE
p=list(formula=~1, share=TRUE,
fixed=list(index=up,value=0)) #p set to zero for unobs
# f0 IS THE THE NUMBER OF FISH NEVER ENCOUNTERED
# AS A LINEAR COMBINATION, NEED TO ALLOW IT TO VARY
# AMONG EACH PRIMARY OCCASION WHICH IS DONE BY SETTING UP
# A DESIGN MATRIX THAT WILL ESTIMATE AN EFFECT OF EACH PRIMARY
# OCCASION, THEN TOTAL ABUNDANDANCE IS DERIVED AS THE LINEAR COMBO
# OF THE INTERCEPT, TIME SPECIFIC EFFECT AND NUMBER OF TAGGED FISH
# CAPTURED AT THAT TIME
# Default: f0<- list(formula=~session)  # NUMBER NOT ENCOUNTERED
# MARKOV MOVEMENT HETEROGENEOUS IN TIME
# SIMULATED MOVEMENT RATES DEPENDENT ON CURRENT STATE
# MOVEMENT RATES DIFFER BASED ON WHICH STATE THE FISH IS HEADED TO
Psi=list(formula=~-1+stratum:tostratum)
# DO WE WANT THIS DEPENDENT ON ANYTHING ELSE...E.G. TIME???
# ARE WE GOING TO HAVE A WAY TO COMPARED MODELS AND CHOOSE "BEST" OR WEIGHT???
# FIT THE MODEL USING PROGRAM MARK
fit<-mark(data=crdms,
ddl=crdms.ddl,
model="CRDMS",
time.intervals = time.intervals,
model.parameters=list(S=S,
p=p,
c = list(fixed=list(index=uc, value=0)),
Psi=Psi),
threads=2,
brief=TRUE)
indx<-lapply(states,grep, x=datg$ch)
samp_size<-lapply(indx,length)
samp_size<-rep(unlist(samp_size),each=inputs$nyears)
params<-fit$results$real[which(!duplicated(fit$results$real$estimate)),]
params<-params[which(params$fixed!="Fixed"),1:4]
if(length(which(params$note!="                    "))>0){return(print("NOTES!"))}
n<-length(states)*inputs$nyears
ests<-data.frame(gear=rep(g,n),
state=rep(states, each=inputs$nyears),
year=rep(1:inputs$nyears, length(states)),
state_samp_size=samp_size,
basin_samp_size=rep(sum(datg$freq),n),
Nhat=fit$results$derived$`N Population Size`$estimate[1:n],
SE_Nhat=fit$results$derived$`N Population Size`$se[1:n],
LC_Nhat=fit$results$derived$`N Population Size`$lcl[1:n],
UC_Nhat=fit$results$derived$`N Population Size`$ucl[1:n],
fit=fit$output)
ests$basin<-ifelse(b==1, "LB","UB")
ss<-ddply(catch, .(basin, st_code, year, gear, b_segment), summarize,
no_of_bends=length(unique(bend_num)))
names(ss)[2]<-"state"
names(ss)[5]<-"segment"
ests<-merge(ests,ss,by=c("basin","state","year","gear"), all.x=TRUE)
keep<-list(abundance=ests,
parameters=cbind(gear=rep(g,nrow(params)),params,
fit=rep(fit$output,nrow(params))),
model=data.frame(fit_type=fit$model.name, fit=fit$output))
return(keep) # REALLY NEED A TABLE OUTPUT BASED ON FIT, I WOULD THINK
})
abund<-do.call(rbind,lapply(outg, `[[`, 1))
param<-do.call(rbind,lapply(outg, `[[`, 2))
model<-do.call(rbind,lapply(outg, `[[`, 3))
outg<-list(abundance=abund,parameters=param, model=model)
return(outg)
})
length(ch)
b<-1
dat<-ch[[b]]
gears<-unique(dat$gear)
if(length(ch)==1){states<-unique(catch$st_code)}
if(length(ch)==2)
{
if(b==1){states<-unique(catch[which(catch$basin=="UB"),]$st_code)}
if(b==2){states<-unique(catch[which(catch$basin=="LB"),]$st_code)}
}
if(length(ch)!=1 & length(ch)!=2){return(print("Issue with capture history length."))}
head(catch)
outg<-lapply(gears, function(g) #LOOP OVER GEARS
{
datg<-dat[which(dat$gear==g),1:2]
crdms<-process.data(data=datg, # CAPTURE HISTORIES FOR EACH FISH
model="CRDMS",  # MODEL TYPE
time.interval=occs, # FUNKY INPUTS TO DEFINE PRIMARY AND SECONDARY OCCASIONS
strata.labels=c(as.character(states), "U")) #DEFINE STATES
# MAKE ADJUSTMENTS
## Change Psi parameters that are obtained by subtraction so that probability
##  of moving to the unobservable state is determined by subtraction
crdms.ddl<-make.design.data(data=crdms,
parameters=list(Psi=list(
subtract.stratum=rep("U",length(states)+1))))
## Create grouping index for unobserved p and c (i.e., always zero)
up<-as.numeric(row.names(crdms.ddl$p[crdms.ddl$p$stratum=="U",]))
uc<-as.numeric(row.names(crdms.ddl$c[crdms.ddl$c$stratum=="U",]))
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX ASSUMING CONSTANT SURVIVAL
S=list(formula=~1)# SURVIVAL
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX FOR CAPTURE PROBABILITY
# RD CAN DO CAPTURE (P) AND RECAPTURE (C) PROBABILITY
# WE ALLOW P TO CHANGE WITH OCCASION AND STRATA BUT ASSUME C=P AT A GIVEN TIME
# AND PLACE.  THUS, WE FIX C = P USING THE SHARE STATEMENT:  SHARE = TRUE
p=list(formula=~1, share=TRUE,
fixed=list(index=up,value=0)) #p set to zero for unobs
# f0 IS THE THE NUMBER OF FISH NEVER ENCOUNTERED
# AS A LINEAR COMBINATION, NEED TO ALLOW IT TO VARY
# AMONG EACH PRIMARY OCCASION WHICH IS DONE BY SETTING UP
# A DESIGN MATRIX THAT WILL ESTIMATE AN EFFECT OF EACH PRIMARY
# OCCASION, THEN TOTAL ABUNDANDANCE IS DERIVED AS THE LINEAR COMBO
# OF THE INTERCEPT, TIME SPECIFIC EFFECT AND NUMBER OF TAGGED FISH
# CAPTURED AT THAT TIME
# Default: f0<- list(formula=~session)  # NUMBER NOT ENCOUNTERED
# MARKOV MOVEMENT HETEROGENEOUS IN TIME
# SIMULATED MOVEMENT RATES DEPENDENT ON CURRENT STATE
# MOVEMENT RATES DIFFER BASED ON WHICH STATE THE FISH IS HEADED TO
Psi=list(formula=~-1+stratum:tostratum)
# DO WE WANT THIS DEPENDENT ON ANYTHING ELSE...E.G. TIME???
# ARE WE GOING TO HAVE A WAY TO COMPARED MODELS AND CHOOSE "BEST" OR WEIGHT???
# FIT THE MODEL USING PROGRAM MARK
fit<-mark(data=crdms,
ddl=crdms.ddl,
model="CRDMS",
time.intervals = time.intervals,
model.parameters=list(S=S,
p=p,
c = list(fixed=list(index=uc, value=0)),
Psi=Psi),
threads=2,
brief=TRUE)
indx<-lapply(states,grep, x=datg$ch)
samp_size<-lapply(indx,length)
samp_size<-rep(unlist(samp_size),each=inputs$nyears)
params<-fit$results$real[which(!duplicated(fit$results$real$estimate)),]
params<-params[which(params$fixed!="Fixed"),1:4]
if(length(which(params$note!="                    "))>0){return(print("NOTES!"))}
n<-length(states)*inputs$nyears
ests<-data.frame(gear=rep(g,n),
state=rep(states, each=inputs$nyears),
year=rep(1:inputs$nyears, length(states)),
state_samp_size=samp_size,
basin_samp_size=rep(sum(datg$freq),n),
Nhat=fit$results$derived$`N Population Size`$estimate[1:n],
SE_Nhat=fit$results$derived$`N Population Size`$se[1:n],
LC_Nhat=fit$results$derived$`N Population Size`$lcl[1:n],
UC_Nhat=fit$results$derived$`N Population Size`$ucl[1:n],
fit=fit$output)
ests$basin<-ifelse(b==1, "LB","UB")
ss<-ddply(catch, .(basin, st_code, year, gear, b_segment), summarize,
no_of_bends=length(unique(bend_num)))
names(ss)[2]<-"state"
names(ss)[5]<-"segment"
ests<-merge(ests,ss,by=c("basin","state","year","gear"), all.x=TRUE)
keep<-list(abundance=ests,
parameters=cbind(gear=rep(g,nrow(params)),params,
fit=rep(fit$output,nrow(params))),
model=data.frame(fit_type=fit$model.name, fit=fit$output))
return(keep) # REALLY NEED A TABLE OUTPUT BASED ON FIT, I WOULD THINK
})
inputs<-sim_dat$inputs
catch<-sim_dat$catch_dat
samp<-sim_dat$samp_dat
if(is.null(max_occ)){max_occ<-inputs$occasions}
if(max_occ>sim_dat$inputs$occasions | max_occ<2)
{return(print(paste0("max_occ needs to be at least 2 AND less than or equal to ",
inputs$occasions)))}
occ<-as.character(1:max_occ)
catch<-catch[which(catch$occasion %in% occ),] #use the number of occasions to limit the data used
samp<-samp[which(samp$occasion %in% occ),]
nsec<-rep(max_occ,inputs$nyears)
ends<-cumsum(nsec) # last sampling occasion each year
occs<- rep(0,sum(nsec))
occs[ends]<-1# last occasion in primary
occs<- occs[-length(occs)]# drop last 1 for processing
catch$basin<-ifelse(catch$b_segment %in% c(1, 2, 3, 4), "UB", "LB")
catch$st_code<-ifelse(catch$basin=="UB",catch$b_segment, catch$b_segment-6)
if(any(catch$st_code==7)){catch[which(catch$st_code==7),]$st_code<-5}
if(any(catch$st_code==8)){catch[which(catch$st_code==8),]$st_code<-6}
ss<-ddply(catch, .(basin, st_code, year, gear, b_segment), summarize,
no_of_bends=length(unique(bend_num)))
names(ss)[2]<-"state"
names(ss)[5]<-"segment"
if(is.null(gear_combi))
{
ch<-lapply(c("UB", "LB"), function(b)
{
dat<-catch[which(catch$basin==b),]
gears<-unique(dat$gear)
gears<-setdiff(gears, c("MF","OT16"))
bg<-lapply(gears,function(g)
{
pp<- dcast(dat,
fish_id~year+occasion,
value.var="st_code", subset=.(gear==g))
pp$gear<-g
return(pp)
})
bg<-do.call(rbind,bg)
for(i in 2:(ncol(bg)-1))
{
bg[which(is.na(bg[,i])),i]<-0
}
tmp<-matrix(0, nrow=nrow(bg), ncol=max_occ*inputs$nyears)
for(i in 1:ncol(tmp))
{
tmp[,i]<-bg[,i+1]
}
bg$ch<-apply(tmp,1,paste0,collapse="")
bg$freq<-1
bg<-bg[,c("ch", "freq","gear")]
return(bg)
})
}
if(!is.null(gear_combi)){return(print("Different gear combinations not supported
at this time."))}
b<-1
dat<-ch[[b]]
gears<-unique(dat$gear)
if(length(ch)==1){states<-unique(catch$st_code)}
if(length(ch)==2)
{
if(b==1){states<-unique(catch[which(catch$basin=="UB"),]$st_code)}
if(b==2){states<-unique(catch[which(catch$basin=="LB"),]$st_code)}
}
if(length(ch)!=1 & length(ch)!=2){return(print("Issue with capture history length."))}
gears
gears<-gears[c(1,4,5)]
gears
outg<-lapply(gears, function(g) #LOOP OVER GEARS
{
datg<-dat[which(dat$gear==g),1:2]
crdms<-process.data(data=datg, # CAPTURE HISTORIES FOR EACH FISH
model="CRDMS",  # MODEL TYPE
time.interval=occs, # FUNKY INPUTS TO DEFINE PRIMARY AND SECONDARY OCCASIONS
strata.labels=c(as.character(states), "U")) #DEFINE STATES
# MAKE ADJUSTMENTS
## Change Psi parameters that are obtained by subtraction so that probability
##  of moving to the unobservable state is determined by subtraction
crdms.ddl<-make.design.data(data=crdms,
parameters=list(Psi=list(
subtract.stratum=rep("U",length(states)+1))))
## Create grouping index for unobserved p and c (i.e., always zero)
up<-as.numeric(row.names(crdms.ddl$p[crdms.ddl$p$stratum=="U",]))
uc<-as.numeric(row.names(crdms.ddl$c[crdms.ddl$c$stratum=="U",]))
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX ASSUMING CONSTANT SURVIVAL
S=list(formula=~1)# SURVIVAL
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX FOR CAPTURE PROBABILITY
# RD CAN DO CAPTURE (P) AND RECAPTURE (C) PROBABILITY
# WE ALLOW P TO CHANGE WITH OCCASION AND STRATA BUT ASSUME C=P AT A GIVEN TIME
# AND PLACE.  THUS, WE FIX C = P USING THE SHARE STATEMENT:  SHARE = TRUE
p=list(formula=~1, share=TRUE,
fixed=list(index=up,value=0)) #p set to zero for unobs
# f0 IS THE THE NUMBER OF FISH NEVER ENCOUNTERED
# AS A LINEAR COMBINATION, NEED TO ALLOW IT TO VARY
# AMONG EACH PRIMARY OCCASION WHICH IS DONE BY SETTING UP
# A DESIGN MATRIX THAT WILL ESTIMATE AN EFFECT OF EACH PRIMARY
# OCCASION, THEN TOTAL ABUNDANDANCE IS DERIVED AS THE LINEAR COMBO
# OF THE INTERCEPT, TIME SPECIFIC EFFECT AND NUMBER OF TAGGED FISH
# CAPTURED AT THAT TIME
# Default: f0<- list(formula=~session)  # NUMBER NOT ENCOUNTERED
# MARKOV MOVEMENT HETEROGENEOUS IN TIME
# SIMULATED MOVEMENT RATES DEPENDENT ON CURRENT STATE
# MOVEMENT RATES DIFFER BASED ON WHICH STATE THE FISH IS HEADED TO
Psi=list(formula=~-1+stratum:tostratum)
# DO WE WANT THIS DEPENDENT ON ANYTHING ELSE...E.G. TIME???
# ARE WE GOING TO HAVE A WAY TO COMPARED MODELS AND CHOOSE "BEST" OR WEIGHT???
# FIT THE MODEL USING PROGRAM MARK
fit<-mark(data=crdms,
ddl=crdms.ddl,
model="CRDMS",
time.intervals = time.intervals,
model.parameters=list(S=S,
p=p,
c = list(fixed=list(index=uc, value=0)),
Psi=Psi),
threads=2,
brief=TRUE)
indx<-lapply(states,grep, x=datg$ch)
samp_size<-lapply(indx,length)
samp_size<-rep(unlist(samp_size),each=inputs$nyears)
params<-fit$results$real[which(!duplicated(fit$results$real$estimate)),]
params<-params[which(params$fixed!="Fixed"),1:4]
if(length(which(params$note!="                    "))>0){return(print("NOTES!"))}
n<-length(states)*inputs$nyears
ests<-data.frame(gear=rep(g,n),
state=rep(states, each=inputs$nyears),
year=rep(1:inputs$nyears, length(states)),
state_samp_size=samp_size,
basin_samp_size=rep(sum(datg$freq),n),
Nhat=fit$results$derived$`N Population Size`$estimate[1:n],
SE_Nhat=fit$results$derived$`N Population Size`$se[1:n],
LC_Nhat=fit$results$derived$`N Population Size`$lcl[1:n],
UC_Nhat=fit$results$derived$`N Population Size`$ucl[1:n],
fit=fit$output)
ests$basin<-ifelse(b==1, "LB","UB")
ests<-merge(ests,ss,by=c("basin","state","year","gear"), all.x=TRUE)
keep<-list(abundance=ests,
parameters=cbind(gear=rep(g,nrow(params)),params,
fit=rep(fit$output,nrow(params))),
model=data.frame(fit_type=fit$model.name, fit=fit$output))
return(keep) # REALLY NEED A TABLE OUTPUT BASED ON FIT, I WOULD THINK
})
abund<-do.call(rbind,lapply(outg, `[[`, 1))
param<-do.call(rbind,lapply(outg, `[[`, 2))
model<-do.call(rbind,lapply(outg, `[[`, 3))
outg<-list(abundance=abund,parameters=param, model=model)
outg1<-outg
b<-2
dat<-ch[[b]]
gears<-unique(dat$gear)
if(length(ch)==1){states<-unique(catch$st_code)}
if(length(ch)==2)
{
if(b==1){states<-unique(catch[which(catch$basin=="UB"),]$st_code)}
if(b==2){states<-unique(catch[which(catch$basin=="LB"),]$st_code)}
}
if(length(ch)!=1 & length(ch)!=2){return(print("Issue with capture history length."))}
gears
gears<-gears[5:7]
gears
outg<-lapply(gears, function(g) #LOOP OVER GEARS
{
datg<-dat[which(dat$gear==g),1:2]
crdms<-process.data(data=datg, # CAPTURE HISTORIES FOR EACH FISH
model="CRDMS",  # MODEL TYPE
time.interval=occs, # FUNKY INPUTS TO DEFINE PRIMARY AND SECONDARY OCCASIONS
strata.labels=c(as.character(states), "U")) #DEFINE STATES
# MAKE ADJUSTMENTS
## Change Psi parameters that are obtained by subtraction so that probability
##  of moving to the unobservable state is determined by subtraction
crdms.ddl<-make.design.data(data=crdms,
parameters=list(Psi=list(
subtract.stratum=rep("U",length(states)+1))))
## Create grouping index for unobserved p and c (i.e., always zero)
up<-as.numeric(row.names(crdms.ddl$p[crdms.ddl$p$stratum=="U",]))
uc<-as.numeric(row.names(crdms.ddl$c[crdms.ddl$c$stratum=="U",]))
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX ASSUMING CONSTANT SURVIVAL
S=list(formula=~1)# SURVIVAL
# SET UP THE FORMULA AND UNDERLYING DESIGN MATRIX FOR CAPTURE PROBABILITY
# RD CAN DO CAPTURE (P) AND RECAPTURE (C) PROBABILITY
# WE ALLOW P TO CHANGE WITH OCCASION AND STRATA BUT ASSUME C=P AT A GIVEN TIME
# AND PLACE.  THUS, WE FIX C = P USING THE SHARE STATEMENT:  SHARE = TRUE
p=list(formula=~1, share=TRUE,
fixed=list(index=up,value=0)) #p set to zero for unobs
# f0 IS THE THE NUMBER OF FISH NEVER ENCOUNTERED
# AS A LINEAR COMBINATION, NEED TO ALLOW IT TO VARY
# AMONG EACH PRIMARY OCCASION WHICH IS DONE BY SETTING UP
# A DESIGN MATRIX THAT WILL ESTIMATE AN EFFECT OF EACH PRIMARY
# OCCASION, THEN TOTAL ABUNDANDANCE IS DERIVED AS THE LINEAR COMBO
# OF THE INTERCEPT, TIME SPECIFIC EFFECT AND NUMBER OF TAGGED FISH
# CAPTURED AT THAT TIME
# Default: f0<- list(formula=~session)  # NUMBER NOT ENCOUNTERED
# MARKOV MOVEMENT HETEROGENEOUS IN TIME
# SIMULATED MOVEMENT RATES DEPENDENT ON CURRENT STATE
# MOVEMENT RATES DIFFER BASED ON WHICH STATE THE FISH IS HEADED TO
Psi=list(formula=~-1+stratum:tostratum)
# DO WE WANT THIS DEPENDENT ON ANYTHING ELSE...E.G. TIME???
# ARE WE GOING TO HAVE A WAY TO COMPARED MODELS AND CHOOSE "BEST" OR WEIGHT???
# FIT THE MODEL USING PROGRAM MARK
fit<-mark(data=crdms,
ddl=crdms.ddl,
model="CRDMS",
time.intervals = time.intervals,
model.parameters=list(S=S,
p=p,
c = list(fixed=list(index=uc, value=0)),
Psi=Psi),
threads=2,
brief=TRUE)
indx<-lapply(states,grep, x=datg$ch)
samp_size<-lapply(indx,length)
samp_size<-rep(unlist(samp_size),each=inputs$nyears)
params<-fit$results$real[which(!duplicated(fit$results$real$estimate)),]
params<-params[which(params$fixed!="Fixed"),1:4]
if(length(which(params$note!="                    "))>0){return(print("NOTES!"))}
n<-length(states)*inputs$nyears
ests<-data.frame(gear=rep(g,n),
state=rep(states, each=inputs$nyears),
year=rep(1:inputs$nyears, length(states)),
state_samp_size=samp_size,
basin_samp_size=rep(sum(datg$freq),n),
Nhat=fit$results$derived$`N Population Size`$estimate[1:n],
SE_Nhat=fit$results$derived$`N Population Size`$se[1:n],
LC_Nhat=fit$results$derived$`N Population Size`$lcl[1:n],
UC_Nhat=fit$results$derived$`N Population Size`$ucl[1:n],
fit=fit$output)
ests$basin<-ifelse(b==1, "LB","UB")
ests<-merge(ests,ss,by=c("basin","state","year","gear"), all.x=TRUE)
keep<-list(abundance=ests,
parameters=cbind(gear=rep(g,nrow(params)),params,
fit=rep(fit$output,nrow(params))),
model=data.frame(fit_type=fit$model.name, fit=fit$output))
return(keep)
fit<-NA; cleanup(ask=FALSE)
})
inputs<-list()
inputs$lower$ln_Linf_mu<-6.982160
inputs$lower$ln_k_mu<- -2.382711
inputs$lower$vcv<- matrix(c(0.0894,-0.1327,-0.1327,0.3179),nrow=2,ncol=2, byrow=TRUE)
inputs$upper$ln_Linf_mu<-7.136028770
inputs$upper$ln_k_mu<- -3.003764445
inputs$upper$vcv<- matrix(c(0.2768,-0.364,-0.364,0.6342),nrow=2,ncol=2, byrow=TRUE)
eigen(inputs$upper$vcv)$vectors
bends<- read.csv("./_dat/bend-data.csv")
names(bends)<- tolower(names(bends))
bends<- subset(bends,b_segment %in% c(1,2,3,4,7,8,9,10,13,14))
bends<-bends[-157,]
bends<-bends[order(bends$lower_river_mile),]
bends$id<- 1:nrow(bends)
bends$lower_rkm<-0
for(i in 2:length(bends$lower_rkm))
{
bends$lower_rkm[i]<-bends$lower_rkm[i-1]+bends$length.rkm[i-1]
}
rm(i)
bends$center<- bends$lower_rkm + bends$length.rkm/2
bends$b_id<- 1
bends$b_id[which(bends$rpma==2)]<- 1:length(which(bends$rpma==2))
bends$b_id[which(bends$rpma==4)]<- 1:length(which(bends$rpma==4))
sp<- list()
tmp<-subset(bends,rpma==2)
tmp<- tmp[order(tmp$lower_river_mile),]
sp$dis$rpma2<- -1*abs(outer(tmp$center,tmp$center,"-"))
sp$direct$rpma2<- sp$dis$rpma2
sp$direct$rpma2[lower.tri(sp$direct$rpma2)]<--1
sp$direct$rpma2[upper.tri(sp$direct$rpma2)]<- 1
tmp<-subset(bends,rpma==4)
tmp<- tmp[order(tmp$lower_river_mile),]
sp$dis$rpma4<- -1*abs(outer(tmp$center,tmp$center,"-"))
sp$direct$rpma4<- sp$dis$rpma4
sp$direct$rpma4[lower.tri(sp$direct$rpma4)]<--1
sp$direct$rpma4[upper.tri(sp$direct$rpma4)]<- 1
rm(tmp)
sp$dis
head(sp$dis$rpma2)
head(sp$dis$rpma2[,1:6])
head(sp$dis$rpma4[,1:6])
mv_beta1[1]
400*4*8
12800/24
(12800/24)/365
400*8/24
(400*8/24)/365
library(RMark)
rm(list=s(all=TRUE))
rm(list=ls(all=TRUE))
